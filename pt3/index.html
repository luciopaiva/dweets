<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Dweets</title>
    <link rel="stylesheet" href="../index.css">
</head>
<body>

<h1>Dweets explained, pt. 3</h1>

<em>by Lucio Paiva (2018-12-02)</em>

<h2>Spread the word around</h2>

<p>In this third part I make my own dweet based on p01's <a href="../pt2/index.html">original idea</a>.</p>

<div class="container">
    <canvas width="1920" height="1080"></canvas>
</div>

<script>
    // this implements all variables defined by dwitter.net for running dweets
    const c = document.querySelector("canvas");
    const x = c.getContext("2d");
    const R = (r, g, b, a) => `rgba(${r},${g},${b},${a})`;
    const T = Math.tan;
    const C = Math.cos;
    const S = Math.sin;

    const update = (t) => {
        u(t/1000);  // dwitter passes time in seconds!
        requestAnimationFrame(update);
    };
    update(performance.now);

    // uncomment to get cool colors
    // x.fillStyle = "#000";
    // x.fillRect(0, 0, c.width, c.height);
    // x.fillStyle = "#0f0";
    function u(t) {
for(i=I=608,c.width=180;a=t+i/I*6.28,i--;)C(a)<0&&x.fillText("░▉"["帀^㰀䉂䉂~䁀䁀繀䰀ሲሒ~䈼䉂㱂縀ဠ‐~㰀䉂䉂<䁀䁀繀䀀䁀䁀~䩂䩊繊縀ࠈࠈ~".charCodeAt(i/16)>>i%16&1],85+S(a)*75,9+i%8*13)
    }
</script>

<a href="">See it on dwitter.net</a>

<p>After studying Henri's code, I decided to change it to become some kind of rotating LED display that shows some message.</p>

<p>Here's my initial code, before any golfing:</p>

<pre>
const d = "帀^㰀䉂䉂~䁀䁀繀䰀ሲሒ~䈼䉂㱂縀ဠ‐~㰀䉂䉂<䁀䁀繀䀀䁀䁀~䩂䩊繊縀ࠈࠈ~";
const w = c.width = 1920 >> 3;

// uncomment to get cool colors
// x.fillStyle = "#000";
// x.fillRect(0, 0, c.width, c.height);
// x.fillStyle = "#0f0";

const nc=76;
for(let i=0;i<8*nc;i++) {
    const ix=i/8|0;
    const a=(ix/nc)*(Math.PI*2);
    if (C(t+a)>0) continue;
    const px=w/2-5+S(t+a)*100;
    const iy=i%8;
    const py=20+iy*15;
    const ci = d.charCodeAt(i/16) >> i % 16 & 1;
    const ch = "░▉"[ci];
    x.fillText(ch, px, py);
}
</pre>

<h2>The algorithm</h2>

<p>Let's start breaking it into parts. First, there's the data string containing the message to be shown. I'm using the same technique described <a href="https://luciopaiva.com/golfer">here</a> to compress the message into an array of bits.</p>

<p>To make the banner I used <a
        href="http://patorjk.com/software/taag/#p=display&f=Banner&t=hello%20world">this online app</a>:</p>

<pre id="banner">
 #    # ###### #      #       ####   #    #  ####  #####  #      #####   ##
 #    # #      #      #      #    #  #    # #    # #    # #      #    #  ##
 ###### #####  #      #      #    #  #    # #    # #    # #      #    #  ##
 #    # #      #      #      #    #  # ## # #    # #####  #      #    #  ##
 #    # #      #      #      #    #  ##  ## #    # #   #  #      #    #
 #    # ###### ###### ######  ####   #    #  ####  #    # ###### #####   ##</pre>

<p>Then I basically got each column of the message and stuffed into one half of a UTF-16 character, bit by bit. Those letters are 6 chars tall, so 1 byte is enough to store a column and we even get 2 extra bits to spare. The message above uses 75 columns. I round it to the next even and, since each UTF-16 character holds 2 columns, I end up with a 38-char data string. Check this page's source code to see how I implemented it. The resulting data is:</p>

<pre id="golfed-banner"></pre>

<script>
    const banner = document.getElementById("banner");
    const lines = banner.innerText.split("\n");
    if (lines.length !== 6) throw new Error("Must have exactly six lines");
    const cols = lines.reduce((w, line) => Math.max(w, line.length), 0) + 1;  // +1 to add trailing space
    if (cols % 2 !== 0) throw new Error("number of columns must be even");
    let result = "";
    for (let j = 0; j < cols; j+=2) {
        let code = 0;
        for (let i = 0; i < 6; i++) {
            // even column goes to highest 8 bits
            code |= (lines[i][j]   === "#" ? 1 : 0) << (i + 1 + 8);
            // odd column goes to lowest 8 bits
            code |= (lines[i][j+1] === "#" ? 1 : 0) << (i + 1);
        }
        let codeStr = code.toString(16);
        codeStr = "0".repeat(4 - codeStr.length) + codeStr;  // left pad with zeros
        result = `%u${codeStr}` + result
    }

    const golfed = unescape(result);
    document.getElementById("golfed-banner").innerText = golfed;
</script>

<p>Next, we have a line setting canvas width. It serves both to set a specific width, but also to clear the canvas. It's a well-known hack that does the same as `x.clearRect(0,0,c.width,c.height), but with less characters. Here I'm using one eighth of the original canvas width, hence the `>> 3` part:</p>

<pre>const w = c.width = 1920 >> 3;</pre>

<p>Then comes the for loop. We'll loop as many times as there are bits in the message (76 columns, each with 8 points):</p>

<pre>
const nc=76;
for(let i=0;i<8*nc;i++) {
</pre>

<p>Now I find out the index of the current column. I do that by performing in integer division by 8, giving me a number between 0 and 75:</p>

<pre>const ix=i/8|0;</pre>

<p>Then I get the current angle of that column with the respect of the rotation of the display:</p>

<pre>const a=(ix/nc)*(Math.PI*2);</pre>

<p>By doing (ix/nc) I map column index to a value in the range [0..1[ and then I multiply it by 2 PI.</p>

<p>Next I do something similar with what Henri did on his code:</p>

<pre>if (C(t+a)>0) continue;</pre>

<p>The difference now is that I cull positive cosines. That has the illusion that the cylinder is rotating clockwise. See, Henri made it rotate counter-clockwise, correctly following the Earth rotation. In my case, however, I want the message to come from right to left, so that's why I needed to invert it.</p>

<p>Now it's time to calculate the x coordinate of the point. Again, this is very similar to what Henri did:</p>

<pre>const px = w/2-5 + S(t+a) * 100;</pre>

<p>I start by adding some constant to center everything horizontally, then I rotate a constant (100) around the y axis to transform a segment into a cylinder.</p>

<p>The y coordinate is even simpler:</p>

<pre>
const iy=i%8;
const py=20+iy*15;
</pre>

<p>I get the remainder of i/8 to serve as my bit index. Bit 0 draws a point in the first row, bit 1 on the second row, and so on, until bit 7 at the bottom row. To calculate py I start by adding a constant that serves as a top margin, then each point gets shifted 15 pixels down times it bit index.</p>

<p>Now, for querying the data:</p>

<pre>
const ci = d.charCodeAt(i/16) >> i % 16 & 1;
const ch = "░▉"[ci];
x.fillText(ch, px, py);
</pre>

<p>We get the UTF-16 character at position i/16, then we use the remainder of this division to fetch the correct bit. We shift it by that amount and then AND it with 1, to isolate it. The resulting character index (ci) is used to know which block character we'll print to the canvas. Then we finally call fillText() to print it. Phew!</p>

<h2>Let's golf it</h2>

<p>Now it's time to get it messier than it already is. This is my initial code:</p>

<pre>
const d = "帀^㰀䉂䉂~䁀䁀繀䰀ሲሒ~䈼䉂㱂縀ဠ‐~㰀䉂䉂<䁀䁀繀䀀䁀䁀~䩂䩊繊縀ࠈࠈ~";
const w = c.width = 1920 >> 3;
const nc=76;
for(let i=0;i<8*nc;i++) {
    const ix=i/8|0;
    const a=(ix/nc)*(Math.PI*2);
    if (C(t+a)>0) continue;
    const px=w/2-5+S(t+a)*100;
    const iy=i%8;
    const py=20+iy*15;
    const ci = d.charCodeAt(i/16) >> i % 16 & 1;
    const ch = "░▉"[ci];
    x.fillText(ch, px, py);
}</pre>

It's 378 chars long, but we don't need consts and lets:

<pre>
d = "帀^㰀䉂䉂~䁀䁀繀䰀ሲሒ~䈼䉂㱂縀ဠ‐~㰀䉂䉂<䁀䁀繀䀀䁀䁀~䩂䩊繊縀ࠈࠈ~";
w = c.width = 1920 >> 3;
nc=76;
for(i=0;i<8*nc;i++) {
ix=i/8|0;
a=(ix/nc)*(Math.PI*2);
if (C(t+a)>0) continue;
px=w/2-5+S(t+a)*100;
iy=i%8;
py=20+iy*15;
ci = d.charCodeAt(i/16) >> i % 16 & 1;
ch = "░▉"[ci];
x.fillText(ch, px, py);
}
</pre>

Down to 278 chars. Cut some variables:

<pre>
d = "帀^㰀䉂䉂~䁀䁀繀䰀ሲሒ~䈼䉂㱂縀ဠ‐~㰀䉂䉂<䁀䁀繀䀀䁀䁀~䩂䩊繊縀ࠈࠈ~";
w = c.width = 240;
nc=76;
for(i=0;i<8*nc;i++) {
a=i/8/nc*Math.PI*2;
if (C(t+a)>0) continue;
x.fillText("░▉"[d.charCodeAt(i/16) >> i % 16 & 1], w/2-5+S(t+a)*100, 20+i%8*15);
}
</pre>

220 chars. Here something interesting happened. I decided to remove the truncation hack (|0) from the column index calculation (ix) and a the display got tilted to the right. I kinda liked it, because it saves me two characters and the final result is interesting, so I'm keeping it, at least for now. Moving on. Let's end with the for block and turn everything into a single statement:

<pre>
d = "帀^㰀䉂䉂~䁀䁀繀䰀ሲሒ~䈼䉂㱂縀ဠ‐~㰀䉂䉂<䁀䁀繀䀀䁀䁀~䩂䩊繊縀ࠈࠈ~";
w = c.width = 240;
nc=76;
for(i=0;i<8*nc;i++)
(a=i/8/nc*Math.PI*2) &&
C(t+a)<0 &&
x.fillText("░▉"[d.charCodeAt(i/16) >> i % 16 & 1], w/2-5+S(t+a)*100, 20+i%8*15)
</pre>

<p>207 chars. Move the data inside, remove some spaces:</p>

<pre>
w=c.width=240;
nc=76;
for(i=0;i<8*nc;i++)
(a=i/8/nc*Math.PI*2) &&
C(t+a)<0 &&
x.fillText("░▉"["帀^㰀䉂䉂~䁀䁀繀䰀ሲሒ~䈼䉂㱂縀ဠ‐~㰀䉂䉂<䁀䁀繀䀀䁀䁀~䩂䩊繊縀ࠈࠈ~".charCodeAt(i/16)>>i%16&1],w/2-5+S(t+a)*100,20+i%8*15)
</pre>

<p>188 chars.</p>

<pre>
w=c.width=240
for(i=0;i<608;i++)
(a=i/8/76*Math.PI*2)&&
C(t+a)<0&&
x.fillText("░▉"["帀^㰀䉂䉂~䁀䁀繀䰀ሲሒ~䈼䉂㱂縀ဠ‐~㰀䉂䉂<䁀䁀繀䀀䁀䁀~䩂䩊繊縀ࠈࠈ~".charCodeAt(i/16)>>i%16&1],w/2-5+S(t+a)*100,20+i%8*15)
</pre>

<p>Getting rid of nc, some spaces and a semicolon I forgot. 177 chars.</p>

<pre>
w=c.width=240
for(i=608;i--;)
(a=i/8/76*Math.PI*2)&&
C(t+a)<0&&
x.fillText("░▉"["帀^㰀䉂䉂~䁀䁀繀䰀ሲሒ~䈼䉂㱂縀ဠ‐~㰀䉂䉂<䁀䁀繀䀀䁀䁀~䩂䩊繊縀ࠈࠈ~".charCodeAt(i/16)>>i%16&1],w/2-5+S(t+a)*100,20+i%8*15)
</pre>

<p>Shorten for loop by merging condition and increment parts and counting down instead of up. 174 chars.</p>

<pre>
c.width=240
for(i=608;i--;)
(a=i/8/76*Math.PI*2)&&
C(t+a)<0&&
x.fillText("░▉"["帀^㰀䉂䉂~䁀䁀繀䰀ሲሒ~䈼䉂㱂縀ဠ‐~㰀䉂䉂<䁀䁀繀䀀䁀䁀~䩂䩊繊縀ࠈࠈ~".charCodeAt(i/16)>>i%16&1],115+S(t+a)*100,20+i%8*15)
</pre>

<p>Got rid of w: 170 chars. I noticed there's a hole in the display, though. It appeared when I changed the for loop to count down. Position zero is never draw because the for now stops as soon as i === 0. Here's the hole:</p>

<img src="hole.png" alt="hole">

<p>To fix it, I just changed 608 to 609. Since that position is an empty space, that's fine. 609 will map outside of the string, returning a NaN. Not a problem, though, because the shift right operation will transform it to zero and everything will be fine. I learned this by finding the bug I mention in the appendix section
    <a href="../pt2/index.html">here</a>. 170 chars, 30 to go.</p>

<pre>
c.width=240
for(i=609;i--;)C(t+(a=i/8/76*Math.PI*2))<0&&x.fillText("░▉"["帀^㰀䉂䉂~䁀䁀繀䰀ሲሒ~䈼䉂㱂縀ဠ‐~㰀䉂䉂<䁀䁀繀䀀䁀䁀~䩂䩊繊縀ࠈࠈ~".charCodeAt(i/16)>>i%16&1],115+S(t+a)*100,20+i%8*15)
</pre>

Now moved variable a inside the cosine function and got rid of some line breaks, down to 164 chars.

<pre>
for(i=609,c.width=240;a=i/8/76*Math.PI*2,i--;)C(t+a)<0&&x.fillText("░▉"["帀^㰀䉂䉂~䁀䁀繀䰀ሲሒ~䈼䉂㱂縀ဠ‐~㰀䉂䉂<䁀䁀繀䀀䁀䁀~䩂䩊繊縀ࠈࠈ~".charCodeAt(i/16)>>i%16&1],115+S(t+a)*100,20+i%8*15)
</pre>

<p>Rearranged it to become a one-liner, but still with 164 chars.</p>

<pre>
for(i=608,c.width=240;a=i/8/76*6.28,i--;)C(t+a)<0&&x.fillText("░▉"["帀^㰀䉂䉂~䁀䁀繀䰀ሲሒ~䈼䉂㱂縀ဠ‐~㰀䉂䉂<䁀䁀繀䀀䁀䁀~䩂䩊繊縀ࠈࠈ~".charCodeAt(i/16)>>i%16&1],115+S(t+a)*100,20+i%8*15)
</pre>

<p>Replaced Math.PI * 2 with 6.28, down to 159 chars. I also noticed that something is causing the first point to be drawn twice. I'm not sure what happened and I don't want to stop now, but it means that my hack is not needed anymore, so i starts with 608 again. 159 chars, 19 to go. I need to attack the angle computation:</p>

<pre>a=i/8/76*6.28</pre>

<p>This is screaming for help. To divide by 8 and then by 76 is the same as dividing by 608, our initial value:</p>

<pre>for(i=I=608,c.width=240;a=i/I*6.28,i--;)</pre>

<p>158. We can also pre-sum t into a and avoid the sum occurring twice (for cosine and then sine):</p>

<pre>for(i=I=608,c.width=240;a=t+i/I*6.28,i--;)C(a)<0&&x.fillText("░▉"["帀^㰀䉂䉂~䁀䁀繀䰀ሲሒ~䈼䉂㱂縀ဠ‐~㰀䉂䉂<䁀䁀繀䀀䁀䁀~䩂䩊繊縀ࠈࠈ~".charCodeAt(i/16)>>i%16&1],115+S(a)*100,20+i%8*15)</pre>

<p>156. By shrinking the canvas a bit, I got rid of some digits in decimal numbers:</p>

<pre>for(i=I=608,c.width=180;a=t+i/I*6.28,i--;)C(a)<0&&x.fillText("░▉"["帀^㰀䉂䉂~䁀䁀繀䰀ሲሒ~䈼䉂㱂縀ဠ‐~㰀䉂䉂<䁀䁀繀䀀䁀䁀~䩂䩊繊縀ࠈࠈ~".charCodeAt(i/16)>>i%16&1],85+S(a)*75,9+i%8*13)</pre>

<p>153 chars, 13 to go. This is getting hard. I believe I still can manage to replace I*6.28 with some pre-baked number, but I'm still far from removing 13 chars. I think I chose a message that is too big. 76 columns are just too much information.</p>

<p>Things to try:</p>

<ul>
    <li>Do not encode top and bottom rows. It would be a potential reduction of 25% in the data, shrinking from 38 down to 29 and I would gain 9 characters. I'm just not sure it will be easy to decode 6 bit columns without requiring more code</li>
    <li>Shrink the message is the easiest one. Each character takes 7 columns, meaning I can gain 7 bytes for every 2 letters removed. If I remove just 4 letters, I can get rid of 14 bytes, coming to a 139-byte dweet. For instance, if the message was just "DWITTER", it would fit perfectly :-)</li>
    <li>I also believe it could be possible to avoid culled points altogether, getting rid of the cosine check. I'm not very confident about it, but it's worth looking into it.</li>
</ul>

</body>
</html>
